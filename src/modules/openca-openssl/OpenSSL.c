/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.16 from the
 * contents of OpenSSL.xs. Do not edit this file, edit OpenSSL.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "OpenSSL.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#define BLOCK	OSSL_BLOCK

#include <openssl/opensslv.h>
#include <openssl/opensslconf.h>

#include <openssl/asn1.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/rand.h>

static char *prqp_exts[] = {
        /* PRQP extended key usage - id-kp-PRQPSigning ::= { id-kp 10 }*/
        "1.3.6.1.5.5.7.3.11", "prqpSigning", "PRQP Signing",
        /* PRQP PKIX identifier - id-prqp ::= { id-pkix 23 } */
        "1.3.6.1.5.5.7.23", "PRQP", "PKI Resource Query Protocol",
        /* PRQP PKIX - PTA identifier - { id-prqp 1 } */
        "1.3.6.1.5.5.7.23.1", "PTA", "PRQP Trusted Authority",
        /* PRQP AD id-ad-prqp ::= { id-ad   12 } */
        "1.3.6.1.5.5.7.48.12", "prqp", "PRQP Service",
        /* End of the List */
        NULL, NULL, NULL
};

static char *prqp_exts_services[] = {
        "1.3.6.1.5.5.7.48.12.0", "rqa", "PRQP RQA Server",
        "1.3.6.1.5.5.7.48.12.1", "ocspServer", "OCSP Server",
        "1.3.6.1.5.5.7.48.12.2", "subjectCert", "Subject Certificate Retieval URI",
        "1.3.6.1.5.5.7.48.12.3", "issuerCert", "Issuer's Certificate Retieval URI",
        "1.3.6.1.5.5.7.48.12.4", "timeStamping", "TimeStamping Service",
        /* PKIX - not yet defined */
        "1.3.6.1.5.5.7.48.12.5", "scvp", "SCVP Service",
        "1.3.6.1.5.5.7.48.12.6", "crlDistribution", "Latest CRL URI",
        "1.3.6.1.5.5.7.48.12.7", "certRepository", "CMS Certificate Repository",
        "1.3.6.1.5.5.7.48.12.8", "crlRepository", "CMS CRL Repository",
        "1.3.6.1.5.5.7.48.12.9", "crossCertRepository", "CMS Cross Certificate Repository",
        /* Gateways */
        "1.3.6.1.5.5.7.48.12.10", "cmcGateway", "CMC Gateway",
        "1.3.6.1.5.5.7.48.12.11", "scepGateway", "SCEP Gateway",
        "1.3.6.1.5.5.7.48.12.12", "htmlGateway", "HTML Gateway",
        "1.3.6.1.5.5.7.48.12.13", "xkmsGateway", "XKMS Gateway",
        /* Certificate Policies */
        "1.3.6.1.5.5.7.48.12.20", "certPolicy", "Certificate Policy (CP) URL",
        "1.3.6.1.5.5.7.48.12.21", "certPracticeStatement", "Certificate Practices Statement (CPS) URL",
        "1.3.6.1.5.5.7.48.12.22", "endorsedTA", "CMS Endorsed Trust Anchors",
        /* Level of Assurance (LOA) */
        "1.3.6.1.5.5.7.48.12.25", "loaPolicy", "LOA Policy URL",
        "1.3.6.1.5.5.7.48.12.26", "certLOALevel", "Certificate LOA Modifier URL",
        /* HTTP (Browsers) based services */
        "1.3.6.1.5.5.7.48.12.30", "htmlRequest", "HTML Certificate Request Service URL",
        "1.3.6.1.5.5.7.48.12.31", "htmlRevoke", "HTML Based Certificate Revocation Service URL",
        "1.3.6.1.5.5.7.48.12.32", "htmlRenew", "HTML Certificate Renewal Service URL",
        "1.3.6.1.5.5.7.48.12.33", "htmlSuspend", "HTML Certificate Suspension Service",
        /* Grid Specific Services */
        "1.3.6.1.5.5.7.48.12.50", "gridAccreditationBody", "CA Accreditation Bodies",
        "1.3.6.1.5.5.7.48.12.51", "gridAccreditationPolicy", "CA Accreditation Policy Document(s) URL",
        "1.3.6.1.5.5.7.48.12.52", "gridAccreditationStatus", "CA Accreditation Status Document(s) URL",
        "1.3.6.1.5.5.7.48.12.53", "gridDistributionUpdate", "Grid Distribution Package(s) URL",
        "1.3.6.1.5.5.7.48.12.54", "gridAccreditedCACerts", "Certificates of Currently Accredited CAs",
        /* Trust Anchors Publishing */
        "1.3.6.1.5.5.7.48.71", "apexTampUpdate", "APEX Trust Anchors Update URL",
        "1.3.6.1.5.5.7.48.70", "tampUpdate", "Trust Anchors Update URL",
        /* CA Incident report URL */
        "1.3.6.1.5.5.7.48.90", "caIncidentReport", "CA Incident Report URL",
        /* Private Services */
        "1.3.6.1.5.5.7.48.12.100", "private", "Private Service",
        NULL, NULL, NULL
        };

#define SCEP_CONF_LIST_SIZE     8

#define TRANS_ID_SIZE                           16

typedef struct scep_oid_st {
        int  attr_type;
        char *oid_s;
        char *descr;
        char *long_descr;
        int  nid;
} SCEP_CONF_ATTRIBUTE;

/* These should be in the same order than the SCEP_ATTRIBUTE_list in scep_attrs.c */
typedef enum {
        SCEP_ATTRIBUTE_MESSAGE_TYPE             = 0,
        SCEP_ATTRIBUTE_PKI_STATUS,
        SCEP_ATTRIBUTE_FAIL_INFO,
        SCEP_ATTRIBUTE_SENDER_NONCE,
        SCEP_ATTRIBUTE_RECIPIENT_NONCE,
        SCEP_ATTRIBUTE_TRANS_ID,
        SCEP_ATTRIBUTE_EXTENSION_REQ,
        SCEP_ATTRIBUTE_PROXY_AUTH
} SCEP_ATTRIBUTE_TYPE;

static SCEP_CONF_ATTRIBUTE SCEP_ATTRIBUTE_list [SCEP_CONF_LIST_SIZE] = {
        { SCEP_ATTRIBUTE_MESSAGE_TYPE, "2.16.840.1.113733.1.9.2",
                        "scepMessageType", "SCEP Message Type", -1 },
        { SCEP_ATTRIBUTE_PKI_STATUS, "2.16.840.1.113733.1.9.3",
                        "pkiStatus", "Status", -1 },
        { SCEP_ATTRIBUTE_FAIL_INFO, "2.16.840.1.113733.1.9.4",
                        "failInfo", "Failure Info", -1 },
        { SCEP_ATTRIBUTE_SENDER_NONCE, "2.16.840.1.113733.1.9.5",
                        "senderNonce", "Sender Nonce", -1 },
        { SCEP_ATTRIBUTE_RECIPIENT_NONCE, "2.16.840.1.113733.1.9.6",
                        "recipientNonce", "Recipient Nonce", -1 },
        { SCEP_ATTRIBUTE_TRANS_ID, "2.16.840.1.113733.1.9.7",
                        "transId", "Transaction Identifier", -1 },
        { SCEP_ATTRIBUTE_EXTENSION_REQ, "2.16.840.1.113733.1.9.8",
                        "extensionReq", "Extension Request", -1 },
        { SCEP_ATTRIBUTE_PROXY_AUTH, "1.3.6.1.4.1.4263.5.5",
                        "proxyAuth", "Proxy Authenticator", -1 },
};

#if OPENSSL_VERSION_NUMBER < 0x00908000L
#define OPENSSL_NO_EC
#endif

#ifndef OPENSSL_NO_EC
#include <openssl/ec.h>
#endif

#include "const-c.inc"

#if OPENSSL_VERSION_NUMBER >= 0x10000000L
typedef _STACK STACK;
#endif

/* Standard trick to have a C pointer as a Perl object, see the typemap */
typedef X509          * OpenCA_OpenSSL_X509;
typedef X509_CRL      * OpenCA_OpenSSL_CRL;
typedef NETSCAPE_SPKI * OpenCA_OpenSSL_SPKAC;
typedef X509_REQ      * OpenCA_OpenSSL_PKCS10;

#line 148 "OpenSSL.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 290 "OpenSSL.c"

/* INCLUDE:  Including 'const-xs.inc' from 'OpenSSL.xs' */


XS_EUPXS(XS_OpenCA__OpenSSL_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "./const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	IV		iv;
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 315 "OpenSSL.c"
	SV *	sv = ST(0)
;
	const char *	s = SvPV(sv, len);
#line 18 "./const-xs.inc"
        /* Change this to constant(aTHX_ s, len, &iv, &nv);
           if you need to return both NVs and IVs */
	type = constant(aTHX_ s, len, &iv);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv =
	    sv_2mortal(newSVpvf("%s is not a valid OpenCA::OpenSSL::Fast macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined OpenCA::OpenSSL::Fast macro %s, used",
				   s));
          PUSHs(sv);
          break;
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break;
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing OpenCA::OpenSSL::Fast macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 393 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'OpenSSL.xs' from 'const-xs.inc' */


XS_EUPXS(XS_OpenCA__OpenSSL__X509_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "x509");
    {
	OpenCA_OpenSSL_X509	x509;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		x509 = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("x509 is not of type OpenCA::OpenSSL::X509")
;
#line 149 "OpenSSL.xs"
        X509_free(x509);
#line 421 "OpenSSL.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509__new_from_der); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509__new_from_der)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 154 "OpenSSL.xs"
	unsigned char * dercert;
	SSize_t certlen;
#line 437 "OpenSSL.c"
	OpenCA_OpenSSL_X509	RETVAL;
	SV *	sv = ST(0)
;
#line 157 "OpenSSL.xs"
	dercert = SvPV(sv, certlen);
	RETVAL = d2i_X509(NULL,(const unsigned char **)&dercert,certlen);
#line 444 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::X509",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509__new_from_pem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509__new_from_pem)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 165 "OpenSSL.xs"
	unsigned char * pemcert;
	unsigned char * dercert;
	SSize_t certlen, inlen;
	char inbuf[512];
	BIO *bio_in, *bio_out, *b64;
#line 466 "OpenSSL.c"
	OpenCA_OpenSSL_X509	RETVAL;
	SV *	sv = ST(0)
;
#line 171 "OpenSSL.xs"
	pemcert = SvPV(sv, certlen);
	bio_in  = BIO_new(BIO_s_mem());
	bio_out = BIO_new(BIO_s_mem());
	b64     = BIO_new(BIO_f_base64());

	/* load encoded data into bio_in */
	BIO_write(bio_in, pemcert+27, certlen-27-25);

	/* set EOF for memory bio */
	BIO_set_mem_eof_return(bio_in, 0);

	/* decode data from one bio into another one */
	BIO_push(b64, bio_in);
        while((inlen = BIO_read(b64, inbuf, 512)) > 0)
		BIO_write(bio_out, inbuf, inlen);

	BIO_free(b64);

	/* create dercert */
	certlen = BIO_get_mem_data(bio_out, &dercert);

	/* create cert */
	RETVAL = d2i_X509(NULL,(const unsigned char **)&dercert,certlen);
	BIO_free_all(bio_in);
	BIO_free_all(bio_out);
#line 496 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::X509",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_init_oids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_init_oids)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "void");
    {
#line 202 "OpenSSL.xs"
	int i, ret;
        int nid = NID_undef;
        SCEP_CONF_ATTRIBUTE *curr_oid = NULL;
#line 516 "OpenSSL.c"
	int	RETVAL;
	dXSTARG;
#line 206 "OpenSSL.xs"
        i = 0;
        while( prqp_exts[i] && prqp_exts[i+1] ) {
        	if((ret = OBJ_create(prqp_exts[i], prqp_exts[i+1],
        				prqp_exts[i+2])) == NID_undef) {
        		// return 0;
        	}
        	i = i+3;
        }

        i = 0;
        while( prqp_exts_services[i] && prqp_exts_services[i+1] ) {
        	if((ret = OBJ_create(prqp_exts_services[i],
        		prqp_exts_services[i+1], prqp_exts_services[i+2]))
        							== NID_undef) {
        		// return 0;
        	}
        	i = i+3;
        };

        i = 0;
        while( i < SCEP_CONF_LIST_SIZE ) {
                curr_oid = &SCEP_ATTRIBUTE_list[i];
                if(( nid = OBJ_create(curr_oid->oid_s, curr_oid->descr,
                         	curr_oid->long_descr)) == NID_undef) {
                        // return 0;
                }

                curr_oid->nid = nid;
                i++;
        }

	RETVAL=1;
#line 552 "OpenSSL.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_serial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_serial)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 245 "OpenSSL.xs"
	char * stringval;
#line 571 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 247 "OpenSSL.xs"
	stringval = i2s_ASN1_INTEGER(NULL,X509_get_serialNumber(cert));
	XPUSHs(sv_2mortal(newSVpv(stringval, 0)));
#line 583 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_hex_serial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_hex_serial)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 254 "OpenSSL.xs"
	ASN1_INTEGER *val;
	long i, idx;
	char *retVal;
#line 604 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 258 "OpenSSL.xs"
	if((val = X509_get_serialNumber(cert)) != NULL ) {
		retVal = malloc ( 2 + (val->length * 3) + 1 );
		idx = 2;
		sprintf(retVal, "0x");
		for (i=0; i < val->length; i++) {
			sprintf( &retVal[idx], "%02x%c", val->data[i], 
				((i+1 == val->length)?'\x0':':'));
			idx += 3;
		}
		XPUSHs(sv_2mortal(newSVpv(retVal, 0)));
	} else {
		XPUSHs(sv_2mortal(newSVpv(strdup("0x0"), 0)));
	}
#line 627 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_subject); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_subject)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 276 "OpenSSL.xs"
	BIO *out;
	unsigned char *subject, *result;
	int n;
#line 648 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 280 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	X509_NAME_print_ex(out, X509_get_subject_name(cert), 0, XN_FLAG_RFC2253&(~ASN1_STRFLGS_ESC_MSB));
	n = BIO_get_mem_data(out, &subject);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, subject, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 666 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_openssl_subject); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_openssl_subject)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 293 "OpenSSL.xs"
	BIO *out;
	unsigned char *subject, *result;
	int n;
#line 687 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 297 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	X509_NAME_print_ex(out, X509_get_subject_name(cert), 0, 0);
	n = BIO_get_mem_data(out, &subject);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, subject, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 705 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_issuer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_issuer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 310 "OpenSSL.xs"
	BIO *out;
	unsigned char *issuer, *result;
	int n;
#line 726 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 314 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	X509_NAME_print_ex(out, X509_get_issuer_name(cert), 0, XN_FLAG_RFC2253&(~ASN1_STRFLGS_ESC_MSB));
	n = BIO_get_mem_data(out, &issuer);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, issuer, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 744 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_notBefore); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_notBefore)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 327 "OpenSSL.xs"
	unsigned char *not, *result;
	int n;
	BIO *out;
#line 765 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 331 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ASN1_TIME_print(out, X509_get_notBefore(cert));
	n = BIO_get_mem_data(out, &not);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, not, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 783 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_notAfter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_notAfter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 344 "OpenSSL.xs"
	unsigned char *not, *result;
	int n;
	BIO *out;
#line 804 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 348 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ASN1_TIME_print(out, X509_get_notAfter(cert));
	n = BIO_get_mem_data(out, &not);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, not, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 822 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_alias); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_alias)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 361 "OpenSSL.xs"
	char *result;
#line 841 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 363 "OpenSSL.xs"
	result = X509_alias_get0(cert, NULL);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
#line 853 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_fingerprint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_fingerprint)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "cert, digest_name=\"sha1\"");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
	char *	digest_name;
#line 371 "OpenSSL.xs"
	BIO *out;
	int j;
	unsigned int n;
	const EVP_MD *digest;
	unsigned char * fingerprint, *result;
	unsigned char md[EVP_MAX_MD_SIZE];
	unsigned char str[3];
#line 879 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;

	if (items < 2)
	    digest_name = "sha1";
	else {
	    digest_name = (char *)SvPV_nolen(ST(1))
;
	}
#line 379 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	if (!strcmp ("sha1", digest_name))
		digest = EVP_sha1();
	else
		digest = EVP_md5();
	if (X509_digest(cert,digest,md,&n))
	{
		/* BIO_printf(out, "%s:", OBJ_nid2sn(EVP_MD_type(digest))); */
		for (j=0; j<(int)n; j++) {
			BIO_printf (out, "%02x",md[j]);
			/* if (j+1 != (int)n) BIO_printf(out,":"); */
		}
	}
	n = BIO_get_mem_data(out, &fingerprint);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, fingerprint, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 915 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_subject_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_subject_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    {
	OpenCA_OpenSSL_X509	cert;
#line 403 "OpenSSL.xs"
#line 931 "OpenSSL.c"
	unsigned long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 404 "OpenSSL.xs"
	RETVAL = X509_subject_name_hash(cert);
#line 944 "OpenSSL.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_emailaddress); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_emailaddress)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 412 "OpenSSL.xs"
	int j, n;
	STACK_OF(OPENSSL_STRING) *emlst;
	BIO *out;
	unsigned char *emails, *result;
#line 966 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 417 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	emlst = X509_get1_email(cert);
	for (j = 0; j < sk_num((STACK *)emlst); j++)
	{
		BIO_printf(out, "%s", sk_value((STACK *)emlst, j));
		if (j+1 != (int)sk_num((STACK *)emlst))
			BIO_printf(out,"\n");
	}
	X509_email_free(emlst);
	n = BIO_get_mem_data(out, &emails);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, emails, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 991 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 437 "OpenSSL.xs"
	BIO *out;
	unsigned char *version, *result;
	unsigned char buf[1024];
	long l;
#line 1013 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 442 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	l = X509_get_version(cert);
	BIO_printf (out,"%lu (0x%lx)",l+1,l);
	l = BIO_get_mem_data(out, &version);
	result = (char *) malloc (l+1);
	result[l] = '\0';
	memcpy (result, version, l);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 1032 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_pubkey_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_pubkey_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 456 "OpenSSL.xs"
	BIO *out;
	unsigned char *pubkey, *result;
	X509_CINF *ci;
	int n;
#line 1054 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 461 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ci = cert->cert_info;
	i2a_ASN1_OBJECT(out, ci->key->algor->algorithm);
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 1073 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_pubkey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_pubkey)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 475 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *pubkey, *result;
	int n;
#line 1095 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 480 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_get_pubkey(cert);
	if (pkey != NULL)
	{
		if (pkey->type == EVP_PKEY_RSA)
			RSA_print(out,pkey->pkey.rsa,0);
#ifndef OPENSSL_NO_DSA
		else if (pkey->type == EVP_PKEY_DSA)
			DSA_print(out,pkey->pkey.dsa,0);
#endif
#ifndef OPENSSL_NO_EC
		else if (pkey->type == EVP_PKEY_EC)
			EC_KEY_print(out, pkey->pkey.ec,0);
#endif
		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 1127 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_keysize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_keysize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 507 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char * pubkey, *result;
	int n;
	BIGNUM *priv_key;
#ifndef OPENSSL_NO_DSA
	DSA *dsa;
#endif
#ifndef OPENSSL_NO_EC
	EC_KEY *ec;
#endif
	RSA *rsa;
#line 1157 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 520 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_get_pubkey(cert);
	if (pkey != NULL) {
		if (pkey->type == EVP_PKEY_RSA) {
			rsa = EVP_PKEY_get1_RSA(pkey);
			if( rsa ) {
				BIO_printf(out,"%d", BN_num_bits(rsa->n));
			} else {
				BIO_printf(out,"%d", 0);
			}
		}
#ifndef OPENSSL_NO_DSA
		else if (pkey->type == EVP_PKEY_DSA) {
			dsa = EVP_PKEY_get1_DSA(pkey);
			if( dsa ) {
				BIO_printf(out,"%d", BN_num_bits(dsa->pub_key));
			} else {
				BIO_printf(out,"%d", 0);
			}
		}
#endif
#ifndef OPENSSL_NO_EC
		else if (pkey->type == EVP_PKEY_EC) {
			ec = EVP_PKEY_get1_EC_KEY(pkey);
			if( ec ) {
				BIO_printf(out, "%d", EVP_PKEY_bits(pkey));
			} else {
				BIO_printf(out,"%d", -3);
			}
		}
#endif
		else {
			/* Unknown Type! */
			BIO_printf(out,"%d", 0);
		}

		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 1211 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_modulus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_modulus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 569 "OpenSSL.xs"
	unsigned char * modulus, *result;
	BIO *out;
	EVP_PKEY *pkey;
	int n;
#line 1233 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 574 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_get_pubkey(cert);

	if (pkey == NULL) {
		BIO_printf(out,"");
	}
	else if (pkey->type == EVP_PKEY_RSA) {
		BN_print(out,pkey->pkey.rsa->n);
	}
#ifndef OPENSSL_NO_DSA
	else if (pkey->type == EVP_PKEY_DSA) {
		BN_print(out,pkey->pkey.dsa->pub_key);
	}
#endif
#ifndef OPENSSL_NO_EC
	else if (pkey->type == EVP_PKEY_EC) {
		EC_KEY *ec;
		BIGNUM  *pub_key=NULL;
        	BN_CTX  *ctx=NULL;

	        const EC_GROUP *group;
	        const EC_POINT *public_key;

		ec = EVP_PKEY_get1_EC_KEY(pkey);
		if (ec == NULL || (group = EC_KEY_get0_group(ec)) == NULL) {
			// Nothing happens here!
                } else {

        		public_key = EC_KEY_get0_public_key(ec);
        		if ((pub_key = EC_POINT_point2bn(group, public_key,
                		EC_KEY_get_conv_form(ec), NULL, ctx)) != NULL) {

				BN_print(out, pub_key);
                	}
		}
	}
#endif
	else
		BIO_printf(out,"");

	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &modulus);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, modulus, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 1290 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_exponent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_exponent)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 626 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *exponent, *result;
	int n;
#line 1312 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 631 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_get_pubkey(cert);
	if (pkey == NULL) {
		BIO_printf(out,"");
	} else if (pkey->type == EVP_PKEY_RSA) {
		BN_print(out,pkey->pkey.rsa->e);
	} 
#ifndef OPENSSL_NO_DSA
	else if (pkey->type == EVP_PKEY_DSA) {
		BN_print(out,pkey->pkey.dsa->pub_key);
	}
#endif
	else
		BIO_printf(out,"");
	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &exponent);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, exponent, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 1343 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_extensions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_extensions)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 657 "OpenSSL.xs"
	BIO *out;
	unsigned char *ext, *result;
	X509_CINF *ci;
	int n;
#line 1365 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 662 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ci = cert->cert_info;
	result = NULL;
	// there is a bug in X509V3_extensions_print
	// the causes the function to fail if title == NULL and indent == 0
	X509V3_extensions_print(out, NULL, ci->extensions, 0, 4);
	n = BIO_get_mem_data(out, &ext);
	if (n)
	{
		result = (char *) malloc (n+1);
		result [n] = '\0';
		memcpy (result, ext, n);
	}
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 1390 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_signature_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_signature_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 682 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	X509_CINF *ci;
	int n;
#line 1412 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 687 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ci = cert->cert_info;
	i2a_ASN1_OBJECT(out, ci->signature->algorithm);
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 1431 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__X509_signature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__X509_signature)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cert");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_X509	cert;
#line 701 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	int n,i;
	unsigned char *s;
#line 1453 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::X509")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		cert = INT2PTR(OpenCA_OpenSSL_X509,tmp);
        }
        else
        	croak("cert is not of type OpenCA::OpenSSL::X509")
;
#line 706 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	n=cert->signature->length;
	s=cert->signature->data;
	for (i=0; i<n; i++)
	{
		if ( ((i%18) == 0) && (i!=0) ) BIO_printf(out,"\n");
		BIO_printf(out,"%02x%s",s[i], (((i+1)%18) == 0)?"":":");
	}
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 1477 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    {
	OpenCA_OpenSSL_CRL	crl;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 728 "OpenSSL.xs"
        X509_CRL_free(crl);
#line 1502 "OpenSSL.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL__new_from_der); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL__new_from_der)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 733 "OpenSSL.xs"
	unsigned char * dercrl;
	SSize_t crllen;
#line 1518 "OpenSSL.c"
	OpenCA_OpenSSL_CRL	RETVAL;
	SV *	sv = ST(0)
;
#line 736 "OpenSSL.xs"
	dercrl = SvPV(sv, crllen);
	RETVAL = d2i_X509_CRL(NULL,(const unsigned char **)&dercrl,crllen);
#line 1525 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::CRL",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL__new_from_pem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL__new_from_pem)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 744 "OpenSSL.xs"
	unsigned char * pemcrl;
	unsigned char * dercrl;
	SSize_t crllen, inlen;
	char inbuf[512];
	BIO *bio_in, *bio_out, *b64;
	X509_CRL *crl;
#line 1548 "OpenSSL.c"
	OpenCA_OpenSSL_CRL	RETVAL;
	SV *	sv = ST(0)
;
#line 751 "OpenSSL.xs"
	pemcrl = SvPV(sv, crllen);
	bio_in  = BIO_new(BIO_s_mem());
	bio_out = BIO_new(BIO_s_mem());
	b64     = BIO_new(BIO_f_base64());

	/* load encoded data into bio_in */
	BIO_write(bio_in, pemcrl+25, crllen-25-23);

	/* set EOF for memory bio */
	BIO_set_mem_eof_return(bio_in, 0);

	/* decode data from one bio into another one */
	BIO_push(b64, bio_in);
        while((inlen = BIO_read(b64, inbuf, 512)) > 0)
		BIO_write(bio_out, inbuf, inlen);

	BIO_free(b64);

	/* create dercert */
	crllen = BIO_get_mem_data(bio_out, &dercrl);

	/* create cert */
	crl = d2i_X509_CRL(NULL,(const unsigned char **)&dercrl,crllen);
	RETVAL = crl;
	BIO_free_all(bio_in);
	BIO_free_all(bio_out);
#line 1579 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::CRL",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 784 "OpenSSL.xs"
	BIO *out;
	unsigned char *version, *result;
	unsigned char buf[1024];
	long l;
#line 1603 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 789 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	l = X509_CRL_get_version(crl);
	BIO_printf (out,"%lu (0x%lx)",l+1,l);
	l = BIO_get_mem_data(out, &version);
	result = (char *) malloc (l+1);
	result[l] = '\0';
	memcpy (result, version, l);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1623 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_issuer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_issuer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 804 "OpenSSL.xs"
	BIO *out;
	unsigned char *issuer, *result;
	int n;
#line 1644 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 808 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	X509_NAME_print_ex(out, X509_CRL_get_issuer(crl), 0, XN_FLAG_RFC2253&(~ASN1_STRFLGS_ESC_MSB));
	n = BIO_get_mem_data(out, &issuer);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, issuer, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1663 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_issuer_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_issuer_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 822 "OpenSSL.xs"
	unsigned long ret;
#line 1682 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 824 "OpenSSL.xs"
	ret = X509_NAME_hash(X509_CRL_get_issuer(crl));
	XPUSHs(sv_2mortal(newSVuv(ret)));
#line 1694 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_lastUpdate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_lastUpdate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 831 "OpenSSL.xs"
	unsigned char *not, *result;
	int n;
	BIO *out;
#line 1715 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 835 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ASN1_TIME_print(out, X509_CRL_get_lastUpdate(crl));
	n = BIO_get_mem_data(out, &not);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, not, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1734 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_nextUpdate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_nextUpdate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 849 "OpenSSL.xs"
	unsigned char *not, *result;
	int n;
	BIO *out;
#line 1755 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 853 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ASN1_TIME_print(out, X509_CRL_get_nextUpdate(crl));
	n = BIO_get_mem_data(out, &not);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, not, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1774 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_fingerprint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_fingerprint)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "crl, digest_name=\"sha1\"");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
	char *	digest_name;
#line 868 "OpenSSL.xs"
	BIO *out;
	int j;
	unsigned int n;
	const EVP_MD *digest;
	unsigned char * fingerprint, *result;
	unsigned char md[EVP_MAX_MD_SIZE];
	unsigned char str[3];
#line 1800 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;

	if (items < 2)
	    digest_name = "sha1";
	else {
	    digest_name = (char *)SvPV_nolen(ST(1))
;
	}
#line 876 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	if (!strcmp ("sha1", digest_name))
		digest = EVP_sha1();
	else
		digest = EVP_md5();
	if (X509_CRL_digest(crl,digest,md,&n))
	{
		BIO_printf(out, "%s:", OBJ_nid2sn(EVP_MD_type(digest)));
		for (j=0; j<(int)n; j++)
		{
			BIO_printf (out, "%02X",md[j]);
			if (j+1 != (int)n) BIO_printf(out,":");
		}
	}
	n = BIO_get_mem_data(out, &fingerprint);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, fingerprint, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1838 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_signature_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_signature_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 902 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	X509_CINF *ci;
	int n;
#line 1860 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 907 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	i2a_ASN1_OBJECT(out, crl->sig_alg->algorithm);
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1879 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_signature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_signature)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 921 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	int n,i;
	unsigned char *s;
#line 1901 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 926 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	n=crl->signature->length;
	s=crl->signature->data;
	for (i=0; i<n; i++)
	{
		if ( ((i%18) == 0) && (i!=0) ) BIO_printf(out,"\n");
		BIO_printf(out,"%02x%s",s[i], (((i+1)%18) == 0)?"":":");
	}
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1926 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_extensions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_extensions)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 946 "OpenSSL.xs"
	BIO *out;
	unsigned char *ext, *result;
	int n;
#line 1947 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 950 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	result = NULL;
	// there is a bug in X509V3_extensions_print
	// the causes the function to fail if title == NULL and indent == 0
	X509V3_extensions_print(out, NULL, crl->crl->extensions, 0, 4);
	n = BIO_get_mem_data(out, &ext);
	if (n)
	{
		result = (char *) malloc (n+1);
		result [n] = '\0';
		memcpy (result, ext, n);
	}
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 1972 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_serial); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_serial)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 970 "OpenSSL.xs"
	ASN1_INTEGER *aint;
	long ret;
#line 1992 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 973 "OpenSSL.xs"
	ret = -1;
	aint = X509_CRL_get_ext_d2i (crl, NID_crl_number, NULL, NULL);
	if (aint != NULL)
        {
	    ret = ASN1_INTEGER_get (aint);
            ASN1_INTEGER_free(aint);
        }
	XPUSHs(sv_2mortal(newSViv(ret)));
#line 2010 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__CRL_revoked); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__CRL_revoked)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "crl");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_CRL	crl;
#line 986 "OpenSSL.xs"
	BIO *out;
	unsigned char *ext, *result;
	int n,i;
	STACK_OF(X509_REVOKED) *rev;
	X509_REVOKED *r;
#line 2033 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::CRL")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		crl = INT2PTR(OpenCA_OpenSSL_CRL,tmp);
        }
        else
        	croak("crl is not of type OpenCA::OpenSSL::CRL")
;
#line 992 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	result = NULL;
	// there is a bug in X509V3_extensions_print
	// the causes the function to fail if title == NULL and indent == 0

	rev = X509_CRL_get_REVOKED(crl);

	for(i = 0; i < sk_X509_REVOKED_num(rev); i++) {
		r = sk_X509_REVOKED_value(rev, i);
		i2a_ASN1_INTEGER(out,r->serialNumber);
		BIO_printf(out,"\n        ");
		ASN1_TIME_print(out,r->revocationDate);
		BIO_printf(out,"\n");
		X509V3_extensions_print(out, NULL,
			r->extensions, 0, 8);
	}
	n = BIO_get_mem_data(out, &ext);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, ext, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	free(result);
	BIO_free(out);
#line 2066 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    {
	OpenCA_OpenSSL_SPKAC	spkac;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1023 "OpenSSL.xs"
	NETSCAPE_SPKI_free(spkac);
#line 2091 "OpenSSL.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 1028 "OpenSSL.xs"
	unsigned char * spkac;
	SSize_t len;
	BIO *bio;
	CONF *conf = NULL;
	int i;
	char *spkstr = NULL;
#line 2111 "OpenSSL.c"
	OpenCA_OpenSSL_SPKAC	RETVAL;
	SV *	sv = ST(0)
;
#line 1035 "OpenSSL.xs"
	spkac = SvPV(sv, len);

	bio  = BIO_new(BIO_s_mem());

	/* load encoded data into bio */
	BIO_write(bio, spkac, len);

        conf = NCONF_new(NULL);
        i = NCONF_load_bio(conf, bio, NULL);

        if(!i) {
		exit (100);
        }

        spkstr = NCONF_get_string(conf, "default", "SPKAC");

	/* RETVAL = NETSCAPE_SPKI_b64_decode(spkac, len); */
	RETVAL = NETSCAPE_SPKI_b64_decode(spkstr, -1);
#line 2134 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::SPKAC",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_pubkey_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_pubkey_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1060 "OpenSSL.xs"
	BIO *out;
	unsigned char *pubkey, *result;
	X509_CINF *ci;
	int n;
#line 2158 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1065 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	i2a_ASN1_OBJECT(out, spkac->spkac->pubkey->algor->algorithm);
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2176 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_pubkey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_pubkey)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1078 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *pubkey, *result;
	int n;
#line 2198 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1083 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_PUBKEY_get(spkac->spkac->pubkey);
	if (pkey != NULL)
	{
		if (pkey->type == EVP_PKEY_RSA)
			RSA_print(out,pkey->pkey.rsa,0);
		else if (pkey->type == EVP_PKEY_DSA)
			DSA_print(out,pkey->pkey.dsa,0);
		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2224 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_keysize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_keysize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1104 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char * pubkey, *result;
	int n;
#line 2246 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1109 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_PUBKEY_get(spkac->spkac->pubkey);
	if (pkey != NULL)
	{
		if (pkey->type == EVP_PKEY_RSA)
			BIO_printf(out,"%d", BN_num_bits(pkey->pkey.rsa->n));
		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2270 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_modulus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_modulus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1128 "OpenSSL.xs"
	unsigned char * modulus, *result;
	BIO *out;
	EVP_PKEY *pkey;
	int n;
#line 2292 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1133 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_PUBKEY_get(spkac->spkac->pubkey);
	if (pkey == NULL)
		BIO_printf(out,"");
	else if (pkey->type == EVP_PKEY_RSA)
		BN_print(out,pkey->pkey.rsa->n);
	else if (pkey->type == EVP_PKEY_DSA)
		BN_print(out,pkey->pkey.dsa->pub_key);
	else
		BIO_printf(out,"");
	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &modulus);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, modulus, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2319 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_exponent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_exponent)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1155 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *exponent, *result;
	int n;
#line 2341 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1160 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_PUBKEY_get(spkac->spkac->pubkey);
	if (pkey == NULL)
		BIO_printf(out,"");
	else if (pkey->type == EVP_PKEY_RSA)
		BN_print(out,pkey->pkey.rsa->e);
	else if (pkey->type == EVP_PKEY_DSA)
		BN_print(out,pkey->pkey.dsa->pub_key);
	else
		BIO_printf(out,"");
	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &exponent);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, exponent, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2368 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_signature_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_signature_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1182 "OpenSSL.xs"
	unsigned char *result;
#line 2387 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1184 "OpenSSL.xs"
	result = (char *) malloc (1);
	result [0] = '\0';
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
#line 2400 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_signature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__SPKAC_signature)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "spkac");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_SPKAC	spkac;
#line 1192 "OpenSSL.xs"
	unsigned char *result;
#line 2419 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::SPKAC")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		spkac = INT2PTR(OpenCA_OpenSSL_SPKAC,tmp);
        }
        else
        	croak("spkac is not of type OpenCA::OpenSSL::SPKAC")
;
#line 1194 "OpenSSL.xs"
	result = (char *) malloc (1);
	result [0] = '\0';
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
#line 2432 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pkcs10");
    {
	OpenCA_OpenSSL_PKCS10	pkcs10;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		pkcs10 = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("pkcs10 is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1205 "OpenSSL.xs"
	X509_REQ_free(pkcs10);
#line 2457 "OpenSSL.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10__new_from_der); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10__new_from_der)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 1210 "OpenSSL.xs"
	unsigned char * dercsr;
	SSize_t csrlen;
#line 2473 "OpenSSL.c"
	OpenCA_OpenSSL_PKCS10	RETVAL;
	SV *	sv = ST(0)
;
#line 1213 "OpenSSL.xs"
	dercsr = SvPV(sv, csrlen);
	RETVAL = d2i_X509_REQ(NULL,(const unsigned char **)&dercsr,csrlen);
#line 2480 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::PKCS10",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10__new_from_pem); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10__new_from_pem)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
#line 1221 "OpenSSL.xs"
	unsigned char * pemcsr;
	unsigned char * dercsr;
	SSize_t csrlen, inlen;
	char inbuf[512];
	BIO *bio_in, *bio_out, *b64;
#line 2502 "OpenSSL.c"
	OpenCA_OpenSSL_PKCS10	RETVAL;
	SV *	sv = ST(0)
;
#line 1227 "OpenSSL.xs"
	pemcsr  = SvPV(sv, csrlen);
	bio_in  = BIO_new(BIO_s_mem());
	bio_out = BIO_new(BIO_s_mem());
	b64     = BIO_new(BIO_f_base64());

	/* load encoded data into bio_in */
	BIO_write(bio_in, pemcsr+36, csrlen-36-34);

	/* set EOF for memory bio */
	BIO_set_mem_eof_return(bio_in, 0);

	/* decode data from one bio into another one */
	BIO_push(b64, bio_in);
        while((inlen = BIO_read(b64, inbuf, 512)) > 0)
		BIO_write(bio_out, inbuf, inlen);

	BIO_free(b64);

	/* create dercsr */
	csrlen = BIO_get_mem_data(bio_out, &dercsr);

	/* create csr */
	RETVAL = d2i_X509_REQ(NULL,(const unsigned char **)&dercsr,csrlen);
	BIO_free_all(bio_in);
	BIO_free_all(bio_out);
#line 2532 "OpenSSL.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "OpenCA::OpenSSL::PKCS10",
	(void*)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1261 "OpenSSL.xs"
	BIO *out;
	unsigned char *version, *result;
	unsigned char buf[1024];
	long l, i;
	const char *neg;
#line 2557 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1267 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());

	neg=(csr->req_info->version->type == V_ASN1_NEG_INTEGER)?"-":"";
	l=0;
	for (i=0; i<csr->req_info->version->length; i++)
		{ l<<=8; l+=csr->req_info->version->data[i]; }
	/* why we use l and not l+1 like for all other versions? */
	BIO_printf(out,"%s%lu (%s0x%lx)",neg,l,neg,l);
	l = BIO_get_mem_data(out, &version);
	result = (char *) malloc (l+1);
	result[l] = '\0';
	memcpy (result, version, l);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2581 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_subject); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_subject)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1286 "OpenSSL.xs"
	BIO *out;
	unsigned char *subject, *result;
	int n;
#line 2602 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1290 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	X509_NAME_print_ex(out, csr->req_info->subject, 0, XN_FLAG_RFC2253&(~ASN1_STRFLGS_ESC_MSB));
	n = BIO_get_mem_data(out, &subject);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, subject, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2620 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_subject_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_subject_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1303 "OpenSSL.xs"
#line 2636 "OpenSSL.c"
	unsigned long	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1304 "OpenSSL.xs"
	RETVAL = X509_NAME_hash(csr->req_info->subject);
#line 2649 "OpenSSL.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_fingerprint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_fingerprint)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "csr, digest_name=\"sha1\"");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
	char *	digest_name;
#line 1313 "OpenSSL.xs"
	BIO *out;
	int j;
	unsigned int n;
	const EVP_MD *digest;
	unsigned char * fingerprint, *result;
	unsigned char md[EVP_MAX_MD_SIZE];
	unsigned char str[3];
#line 2675 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;

	if (items < 2)
	    digest_name = "sha1";
	else {
	    digest_name = (char *)SvPV_nolen(ST(1))
;
	}
#line 1321 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	if (!strcmp ("sha1", digest_name))
		digest = EVP_sha1();
	else
		digest = EVP_md5();
	if (X509_REQ_digest(csr,digest,md,&n))
	{
		BIO_printf(out, "%s:", OBJ_nid2sn(EVP_MD_type(digest)));
		for (j=0; j<(int)n; j++)
		{
			BIO_printf (out, "%02X",md[j]);
			if (j+1 != (int)n) BIO_printf(out,":");
		}
	}
	n = BIO_get_mem_data(out, &fingerprint);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, fingerprint, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2712 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_emailaddress); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_emailaddress)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1346 "OpenSSL.xs"
	int j, n;
        STACK_OF(OPENSSL_STRING) *emlst;
	BIO *out;
	unsigned char *emails, *result;
#line 2734 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1351 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	emlst = X509_REQ_get1_email(csr);
	for (j = 0; j < sk_num((STACK *)emlst); j++)
	{
		BIO_printf(out, "%s", sk_value((STACK *)emlst, j));
		if (j+1 != (int)sk_num((STACK *)emlst))
			BIO_printf(out,"\n");
	}
	X509_email_free(emlst);
	n = BIO_get_mem_data(out, &emails);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, emails, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2759 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_pubkey_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_pubkey_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1371 "OpenSSL.xs"
	BIO *out;
	unsigned char *pubkey, *result;
	X509_REQ_INFO *ri;
	int n;
#line 2781 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1376 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	ri = csr->req_info;
	i2a_ASN1_OBJECT(out, ri->pubkey->algor->algorithm);
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2800 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_pubkey); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_pubkey)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1390 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *pubkey, *result;
	int n;
#line 2822 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1395 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_REQ_get_pubkey(csr);
	if (pkey != NULL)
	{
		if (pkey->type == EVP_PKEY_RSA) {
			RSA_print(out,pkey->pkey.rsa,0);
		}
#ifndef OPENSSL_NO_DSA
		else if (pkey->type == EVP_PKEY_DSA) {
			DSA_print(out,pkey->pkey.dsa,0);
		}
#endif
#ifndef OPENSSL_NO_EC
		else if (pkey->type == EVP_PKEY_EC) {
			EC_KEY_print(out, pkey->pkey.ec,0);
		}
#endif
		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result[n] = '\0';
	memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2857 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_keysize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_keysize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1425 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char * pubkey, *result;
	int n;
	BIGNUM *priv_key;
	RSA *rsa;
#ifndef OPENSSL_NO_DSA
	DSA *dsa;
#endif
#ifndef OPENSSL_NO_EC
	EC_KEY *ec;
#endif
#line 2887 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1438 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_REQ_get_pubkey(csr);
	if (pkey != NULL) {
		if (pkey->type == EVP_PKEY_RSA) {
			rsa = EVP_PKEY_get1_RSA(pkey);
			if( rsa ) {
				BIO_printf(out, "%d", EVP_PKEY_bits(pkey));
				/* BIO_printf(out,"%d",BN_num_bits(rsa->n));*/
			} else {
				BIO_printf(out,"%d", 0);
			}
			/* BIO_printf(out,"%d", BN_num_bits(pkey->pkey.rsa->n)); */
		}
#ifndef OPENSSL_NO_DSA
		else if (pkey->type == EVP_PKEY_DSA) {
			dsa = EVP_PKEY_get1_DSA(pkey);
			if( dsa ) {
				BIO_printf(out, "%d", EVP_PKEY_bits(pkey));
				/*
				BIO_printf(out,"%d", 
					BN_num_bits(dsa->pub_key) + 1);
				*/
			} else {
				BIO_printf(out,"%d", 0);
			}
		}
#endif
#ifndef OPENSSL_NO_EC
		else if (pkey->type == EVP_PKEY_EC) {
			ec = EVP_PKEY_get1_EC_KEY(pkey);
			if( ec ) {
				BIO_printf(out, "%d", EVP_PKEY_bits(pkey));
			} else {
				BIO_printf(out,"%d", -3);
			}
		}
#endif
		else {
			/* Unknown Type! */
			BIO_printf(out,"%d", -1);
		}
		EVP_PKEY_free(pkey);
	}
	n = BIO_get_mem_data(out, &pubkey);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, pubkey, n);
	XPUSHs(sv_2mortal(newSVpv(strdup(result), 0)));
	BIO_free(out);
#line 2946 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_modulus); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_modulus)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1492 "OpenSSL.xs"
	unsigned char * modulus, *result;
	BIO *out;
	EVP_PKEY *pkey;
	int n;
#line 2968 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1497 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_REQ_get_pubkey(csr);
	if (pkey == NULL)
		BIO_printf(out,"");
	else if (pkey->type == EVP_PKEY_RSA)
		BN_print(out,pkey->pkey.rsa->n);
	else if (pkey->type == EVP_PKEY_DSA)
		BN_print(out,pkey->pkey.dsa->pub_key);
	else
		BIO_printf(out,"");
	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &modulus);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, modulus, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 2995 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_exponent); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_exponent)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1519 "OpenSSL.xs"
	BIO *out;
	EVP_PKEY *pkey;
	unsigned char *exponent, *result;
	int n;
#line 3017 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1524 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	pkey=X509_REQ_get_pubkey(csr);
	if (pkey == NULL)
		BIO_printf(out,"");
	else if (pkey->type == EVP_PKEY_RSA)
		BN_print(out,pkey->pkey.rsa->e);
	else if (pkey->type == EVP_PKEY_DSA)
		BN_print(out,pkey->pkey.dsa->pub_key);
	else
		BIO_printf(out,"");
	EVP_PKEY_free(pkey);
	n = BIO_get_mem_data(out, &exponent);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, exponent, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 3044 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_extensions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_extensions)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1546 "OpenSSL.xs"
	BIO *out;
	unsigned char *ext, *result;
	int n;
#line 3065 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1550 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	result = NULL;
	// there is a bug in X509V3_extensions_print
	// the causes the function to fail if title == NULL and indent == 0
	X509V3_extensions_print(out, NULL, X509_REQ_get_extensions(csr), 0, 4);
	n = BIO_get_mem_data(out, &ext);
	if (n)
	{
		result = (char *) malloc (n+1);
		result [n] = '\0';
		memcpy (result, ext, n);
	}
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 3089 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_attributes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1569 "OpenSSL.xs"
	BIO *out;
	unsigned char *ext, *result;
	STACK_OF(X509_ATTRIBUTE) *sk;
	int n,i;
#line 3111 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1574 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	result = NULL;
	sk=csr->req_info->attributes;
	for (i=0; i<sk_X509_ATTRIBUTE_num(sk); i++)
	{
		ASN1_TYPE *at;
		X509_ATTRIBUTE *a;
		ASN1_BIT_STRING *bs=NULL;
		ASN1_TYPE *t;
		int j,type=0,count=1,ii=0;

		a=sk_X509_ATTRIBUTE_value(sk,i);
		if(X509_REQ_extension_nid(OBJ_obj2nid(a->object)))
			continue;
		if ((j=i2a_ASN1_OBJECT(out,a->object)) > 0)
		{
			if (a->single)
			{
				t=a->value.single;
				type=t->type;
				bs=t->value.bit_string;
			}
			else
			{
				ii=0;
				count=sk_ASN1_TYPE_num(a->value.set);
get_next:
				at=sk_ASN1_TYPE_value(a->value.set,ii);
				type=at->type;
				bs=at->value.asn1_string;
			}
		}
		for (j=25-j; j>0; j--)
			BIO_write(out," ",1);
		BIO_puts(out,":");
		if (    (type == V_ASN1_PRINTABLESTRING) ||
			(type == V_ASN1_T61STRING) ||
			(type == V_ASN1_IA5STRING))
		{
			BIO_write(out,(char *)bs->data,bs->length);
			BIO_puts(out,"\n");
		}
		else
			BIO_puts(out,"unable to print attribute\n");
		if (++ii < count) goto get_next;
	}
	n = BIO_get_mem_data(out, &ext);
	if (n)
	{
		result = (char *) malloc (n+1);
		result [n] = '\0';
		memcpy (result, ext, n);
	}
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 3176 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_signature_algorithm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_signature_algorithm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1634 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	int n;
#line 3197 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1638 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	i2a_ASN1_OBJECT(out, csr->sig_alg->algorithm);
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 3215 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_signature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__PKCS10_signature)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "csr");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	OpenCA_OpenSSL_PKCS10	csr;
#line 1651 "OpenSSL.xs"
	BIO *out;
	unsigned char *sig, *result;
	int n,i;
	unsigned char *s;
#line 3237 "OpenSSL.c"

	if (sv_derived_from(ST(0), "OpenCA::OpenSSL::PKCS10")) {
		IV tmp = SvIV((SV*)SvRV(ST(0)));
		csr = INT2PTR(OpenCA_OpenSSL_PKCS10,tmp);
        }
        else
        	croak("csr is not of type OpenCA::OpenSSL::PKCS10")
;
#line 1656 "OpenSSL.xs"
	out = BIO_new(BIO_s_mem());
	n=csr->signature->length;
	s=csr->signature->data;
	for (i=0; i<n; i++)
	{
		if ( ((i%18) == 0) && (i!=0) ) BIO_printf(out,"\n");
		BIO_printf(out,"%02x%s",s[i], (((i+1)%18) == 0)?"":":");
	}
	n = BIO_get_mem_data(out, &sig);
	result = (char *) malloc (n+1);
	result [n] = '\0';
        memcpy (result, sig, n);
	XPUSHs(sv_2mortal(newSVpv(result, 0)));
	BIO_free(out);
#line 3261 "OpenSSL.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_OpenCA__OpenSSL__Misc_rand_bytes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_OpenCA__OpenSSL__Misc_rand_bytes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bytes");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	bytes = (int)SvIV(ST(0))
;
#line 1678 "OpenSSL.xs"
		unsigned char seed[20];
		unsigned char *rnd = NULL;
		char * ret = NULL;
		int i = 0;
		int count = 0;
#line 3285 "OpenSSL.c"
#line 1684 "OpenSSL.xs"
		if ( bytes <= 0 ) {
			XSRETURN_UNDEF;
			return;
		};

        	if (!RAND_pseudo_bytes(seed, 20)) {
			XSRETURN_UNDEF;
        	        return;
        	}
        	RAND_seed(seed, sizeof seed);


		if((rnd = (char *) malloc ( bytes )) == NULL ) {
			XSRETURN_UNDEF;
			return;
		}

		if (!RAND_bytes(rnd, bytes)) {
			XSRETURN_UNDEF;
			return;
		}
		if((ret = (char *) malloc (bytes * 2 + 1)) == NULL ) {
			free (rnd);
			XSRETURN_UNDEF;
			return;
		}

		count = 0;
		for ( i = 0; i < bytes; i++ ) { 
			sprintf( &ret[count], "%2.2X", rnd[i] );
			count = count + 2;
		}
		ret[bytes*2] = '\x0';
		free ( rnd );
		XPUSHs(sv_2mortal(newSVpv(ret, 0)));
#line 3322 "OpenSSL.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_OpenCA__OpenSSL); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_OpenCA__OpenSSL)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        newXS("OpenCA::OpenSSL::constant", XS_OpenCA__OpenSSL_constant, file);
        newXS("OpenCA::OpenSSL::X509::DESTROY", XS_OpenCA__OpenSSL__X509_DESTROY, file);
        newXS("OpenCA::OpenSSL::X509::_new_from_der", XS_OpenCA__OpenSSL__X509__new_from_der, file);
        newXS("OpenCA::OpenSSL::X509::_new_from_pem", XS_OpenCA__OpenSSL__X509__new_from_pem, file);
        newXS("OpenCA::OpenSSL::X509::init_oids", XS_OpenCA__OpenSSL__X509_init_oids, file);
        newXS("OpenCA::OpenSSL::X509::serial", XS_OpenCA__OpenSSL__X509_serial, file);
        newXS("OpenCA::OpenSSL::X509::hex_serial", XS_OpenCA__OpenSSL__X509_hex_serial, file);
        newXS("OpenCA::OpenSSL::X509::subject", XS_OpenCA__OpenSSL__X509_subject, file);
        newXS("OpenCA::OpenSSL::X509::openssl_subject", XS_OpenCA__OpenSSL__X509_openssl_subject, file);
        newXS("OpenCA::OpenSSL::X509::issuer", XS_OpenCA__OpenSSL__X509_issuer, file);
        newXS("OpenCA::OpenSSL::X509::notBefore", XS_OpenCA__OpenSSL__X509_notBefore, file);
        newXS("OpenCA::OpenSSL::X509::notAfter", XS_OpenCA__OpenSSL__X509_notAfter, file);
        newXS("OpenCA::OpenSSL::X509::alias", XS_OpenCA__OpenSSL__X509_alias, file);
        newXS("OpenCA::OpenSSL::X509::fingerprint", XS_OpenCA__OpenSSL__X509_fingerprint, file);
        newXS("OpenCA::OpenSSL::X509::subject_hash", XS_OpenCA__OpenSSL__X509_subject_hash, file);
        newXS("OpenCA::OpenSSL::X509::emailaddress", XS_OpenCA__OpenSSL__X509_emailaddress, file);
        newXS("OpenCA::OpenSSL::X509::version", XS_OpenCA__OpenSSL__X509_version, file);
        newXS("OpenCA::OpenSSL::X509::pubkey_algorithm", XS_OpenCA__OpenSSL__X509_pubkey_algorithm, file);
        newXS("OpenCA::OpenSSL::X509::pubkey", XS_OpenCA__OpenSSL__X509_pubkey, file);
        newXS("OpenCA::OpenSSL::X509::keysize", XS_OpenCA__OpenSSL__X509_keysize, file);
        newXS("OpenCA::OpenSSL::X509::modulus", XS_OpenCA__OpenSSL__X509_modulus, file);
        newXS("OpenCA::OpenSSL::X509::exponent", XS_OpenCA__OpenSSL__X509_exponent, file);
        newXS("OpenCA::OpenSSL::X509::extensions", XS_OpenCA__OpenSSL__X509_extensions, file);
        newXS("OpenCA::OpenSSL::X509::signature_algorithm", XS_OpenCA__OpenSSL__X509_signature_algorithm, file);
        newXS("OpenCA::OpenSSL::X509::signature", XS_OpenCA__OpenSSL__X509_signature, file);
        newXS("OpenCA::OpenSSL::CRL::DESTROY", XS_OpenCA__OpenSSL__CRL_DESTROY, file);
        newXS("OpenCA::OpenSSL::CRL::_new_from_der", XS_OpenCA__OpenSSL__CRL__new_from_der, file);
        newXS("OpenCA::OpenSSL::CRL::_new_from_pem", XS_OpenCA__OpenSSL__CRL__new_from_pem, file);
        newXS("OpenCA::OpenSSL::CRL::version", XS_OpenCA__OpenSSL__CRL_version, file);
        newXS("OpenCA::OpenSSL::CRL::issuer", XS_OpenCA__OpenSSL__CRL_issuer, file);
        newXS("OpenCA::OpenSSL::CRL::issuer_hash", XS_OpenCA__OpenSSL__CRL_issuer_hash, file);
        newXS("OpenCA::OpenSSL::CRL::lastUpdate", XS_OpenCA__OpenSSL__CRL_lastUpdate, file);
        newXS("OpenCA::OpenSSL::CRL::nextUpdate", XS_OpenCA__OpenSSL__CRL_nextUpdate, file);
        newXS("OpenCA::OpenSSL::CRL::fingerprint", XS_OpenCA__OpenSSL__CRL_fingerprint, file);
        newXS("OpenCA::OpenSSL::CRL::signature_algorithm", XS_OpenCA__OpenSSL__CRL_signature_algorithm, file);
        newXS("OpenCA::OpenSSL::CRL::signature", XS_OpenCA__OpenSSL__CRL_signature, file);
        newXS("OpenCA::OpenSSL::CRL::extensions", XS_OpenCA__OpenSSL__CRL_extensions, file);
        newXS("OpenCA::OpenSSL::CRL::serial", XS_OpenCA__OpenSSL__CRL_serial, file);
        newXS("OpenCA::OpenSSL::CRL::revoked", XS_OpenCA__OpenSSL__CRL_revoked, file);
        newXS("OpenCA::OpenSSL::SPKAC::DESTROY", XS_OpenCA__OpenSSL__SPKAC_DESTROY, file);
        newXS("OpenCA::OpenSSL::SPKAC::_new", XS_OpenCA__OpenSSL__SPKAC__new, file);
        newXS("OpenCA::OpenSSL::SPKAC::pubkey_algorithm", XS_OpenCA__OpenSSL__SPKAC_pubkey_algorithm, file);
        newXS("OpenCA::OpenSSL::SPKAC::pubkey", XS_OpenCA__OpenSSL__SPKAC_pubkey, file);
        newXS("OpenCA::OpenSSL::SPKAC::keysize", XS_OpenCA__OpenSSL__SPKAC_keysize, file);
        newXS("OpenCA::OpenSSL::SPKAC::modulus", XS_OpenCA__OpenSSL__SPKAC_modulus, file);
        newXS("OpenCA::OpenSSL::SPKAC::exponent", XS_OpenCA__OpenSSL__SPKAC_exponent, file);
        newXS("OpenCA::OpenSSL::SPKAC::signature_algorithm", XS_OpenCA__OpenSSL__SPKAC_signature_algorithm, file);
        newXS("OpenCA::OpenSSL::SPKAC::signature", XS_OpenCA__OpenSSL__SPKAC_signature, file);
        newXS("OpenCA::OpenSSL::PKCS10::DESTROY", XS_OpenCA__OpenSSL__PKCS10_DESTROY, file);
        newXS("OpenCA::OpenSSL::PKCS10::_new_from_der", XS_OpenCA__OpenSSL__PKCS10__new_from_der, file);
        newXS("OpenCA::OpenSSL::PKCS10::_new_from_pem", XS_OpenCA__OpenSSL__PKCS10__new_from_pem, file);
        newXS("OpenCA::OpenSSL::PKCS10::version", XS_OpenCA__OpenSSL__PKCS10_version, file);
        newXS("OpenCA::OpenSSL::PKCS10::subject", XS_OpenCA__OpenSSL__PKCS10_subject, file);
        newXS("OpenCA::OpenSSL::PKCS10::subject_hash", XS_OpenCA__OpenSSL__PKCS10_subject_hash, file);
        newXS("OpenCA::OpenSSL::PKCS10::fingerprint", XS_OpenCA__OpenSSL__PKCS10_fingerprint, file);
        newXS("OpenCA::OpenSSL::PKCS10::emailaddress", XS_OpenCA__OpenSSL__PKCS10_emailaddress, file);
        newXS("OpenCA::OpenSSL::PKCS10::pubkey_algorithm", XS_OpenCA__OpenSSL__PKCS10_pubkey_algorithm, file);
        newXS("OpenCA::OpenSSL::PKCS10::pubkey", XS_OpenCA__OpenSSL__PKCS10_pubkey, file);
        newXS("OpenCA::OpenSSL::PKCS10::keysize", XS_OpenCA__OpenSSL__PKCS10_keysize, file);
        newXS("OpenCA::OpenSSL::PKCS10::modulus", XS_OpenCA__OpenSSL__PKCS10_modulus, file);
        newXS("OpenCA::OpenSSL::PKCS10::exponent", XS_OpenCA__OpenSSL__PKCS10_exponent, file);
        newXS("OpenCA::OpenSSL::PKCS10::extensions", XS_OpenCA__OpenSSL__PKCS10_extensions, file);
        newXS("OpenCA::OpenSSL::PKCS10::attributes", XS_OpenCA__OpenSSL__PKCS10_attributes, file);
        newXS("OpenCA::OpenSSL::PKCS10::signature_algorithm", XS_OpenCA__OpenSSL__PKCS10_signature_algorithm, file);
        newXS("OpenCA::OpenSSL::PKCS10::signature", XS_OpenCA__OpenSSL__PKCS10_signature, file);
        newXS("OpenCA::OpenSSL::Misc::rand_bytes", XS_OpenCA__OpenSSL__Misc_rand_bytes, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

